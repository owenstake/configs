# Banner {{{
    echo '
          /      \ /  | /  | /  | /      \ /       \
         /$$$$$$  |$$ | $$ | $$ |/$$$$$$  |$$$$$$$  |
         $$ |  $$ |$$ | $$ | $$ |$$    $$ |$$ |  $$ |
         $$ \__$$ |$$ \_$$ \_$$ |$$$$$$$$/ $$ |  $$ |
         $$    $$/ $$   $$   $$/ $$       |$$ |  $$ |
          $$$$$$/   $$$$$/$$$$/   $$$$$$$/ $$/   $$/

    '
    echo "--------------------------------"
    echo "-- owen zsh config -------------"
    echo "--------------------------------"
# }}}

# Intro {{{
    # Just for my own notes / confirmation and to help anybody else, the ultimate order is .zshenv ? [.zprofile if login] ? [.zshrc if interactive] ? [.zlogin if login] ? [.zlogout sometimes].

    # manual config is needed to confirm and add to ~/.zshrc
    export WinUserName=$(echo $PATH | sed 's#.*/mnt/c/Users/\([^/]*\)/.*#\1#')
    export WinUserHome=/mnt/c/Users/${WinUserName}
    export WinUserDownloads=${WinUserHome}/Downloads
    export WinUserDesktop=${WinUserHome}/Desktop
    export WinUserWeiyun="/mnt/c/Weiyun/Personal"
    export WinUserWeiyunNote="/mnt/c/Weiyun/Personal/my_note"
# }}}

# Terminal settings {{{
    # setopt {{{
        setopt BSD_echo # for fix wired "echo ////" problem
        setopt braceccl # for use "vim {ac}file.c

        # fix history share in mutli panel
        setopt inc_append_history
        setopt share_history
    # }}}
# }}}

# Export {{{
    export EDITOR=vim   # For hjkl move

    # lua setting
    export ZLUA_SCRIPT="~/.zplug/repos/skywind3000/z.lua/z.lua"
    # export RANGER_ZLUA=${ZLUA_SCRIPT:-"~/.zplug/repos/skywind3000/z.lua/z.lua"}
    export PshDir='D:\.local\win10\psh\'
    export _ZL_ROOT_MARKERS=".git,.svn,.hg,.root,package.json"    # for `z -b` to return to root dir
    export _ZL_ECHO=1
# }}}

# Aliases ----------------------------------------- {{{

    # Basic alias{{{
        alias                                                 \
        ap='apropos'                                          \
        rp='realpath'                                         \
        vi='vim'                                              \
        hi='history'                                          \
        xc='xclip'                                            \
        fd='fdfind'                                           \
        ra='ranger'                                           \
        wt='curl -s "wttr.in/~haizhu+guangzhou?m" | less'     \
        wtq='curl -s "wttr.in/~Quan+Zhou+Fujian?m" | less'    \
        wtx='curl -s "wttr.in/~xiamen+Fujian?m" | less'       \
        lz='lazygit'                                          \
        nb='newsboat -ru ~/.local/etc/newsboat/rss_links.txt' \
        pg='grep -P'                                          \
        pac="vim ~/.local/etc/pac.txt"                        \
        vic='vim ~/.vimrc'                                    \
        pc='proxychains'                                      \
        psg='ps -ef | grep '                                  \
        py=python
    # }}}

    # zlua {{{
        # <ctrl-t><ctrl-t> for zf in fzf
        # already define in z.lua
        # zz='z -i'  \
        # zf='z -I'  \
        # zb='z -b'  \
        # zbi='z -b -i'  \
        # zbf='z -b -I'  \
        # zh='z -I -t .'  \
        # zzc='zz -c' \

        alias                          \
        zi='z -i'                      \
        zl='z -l'                      \
        zc='z -c'                      \
        zcl='z -c -l'                  \
        zcf='z -c -I'                  \
        zch='z -c -I -t .'             \
        zd="cd $WinUserHome/Downloads" \
        zr="cd $WinUserHome/Desktop"   \
        zp="cd $WinUserWeiyun"         \
        zn="cd $WinUserWeiyun/my_note" \
    # }}}

    # tar .tgz alias {{{
        alias tarc='tar -czvf'
        alias tarl='tar -tf'
        alias tarx='tar -xzvf'
    # }}}

    # LukeSmith - Verbosity and settings that you pretty much just always are going to want.{{{
        alias \
        cp='cp -iv' \
        df='df -h' \
        rm='rm -vI' \
        mkd="mkdir -pv" \
    # }}}

    # Git Alias - ref - liaoxuefeng {{{
        git config --global alias.st status
        git config --global alias.co checkout
        git config --global alias.ci commit
        git config --global alias.br branch
        git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
        git config --global color.ui true
        alias gla='git log --oneline --decorate --all --graph'
    # }}}

    # Zsh config{{{
        alias zshc="vim ~/.zshrc"
        alias zshs="source ~/.zshrc"
    # }}}

    # Tmux alias {{{
        alias \
        ta='tmux a' \
        tn='tmux new -s' \
        tk='tmux kill-session -t' \
        tls='tmux ls' \
        tat='tmux a -t' \
        tmuxc='vim ~/.tmux.conf' \
        tmuxs='tmux source ~/.tmux.conf' \
    # }}}

# }}}

# log function {{{
    FMT_RED=$(printf '\033[31m')
    FMT_GREEN=$(printf '\033[32m')
    FMT_YELLOW=$(printf '\033[33m')
    FMT_BLUE=$(printf '\033[34m')
    FMT_BOLD=$(printf '\033[1m')
    FMT_RESET=$(printf '\033[0m')

    function fmt_info() {
        printf '%sINFO: %s%s\n' "${FMT_GREEN}${FMT_BOLD}" "$*" "$FMT_RESET"
    }

    function fmt_warn() {
        printf '%sWARN: %s%s\n' "${FMT_YELLOW}${FMT_BOLD}" "$*" "$FMT_RESET"
    }

    function fmt_error() {
        printf '%sERRO: [%s] %s%s\n' "${FMT_RED}${FMT_BOLD}" "$funcstack[2] $@" "$*" "$FMT_RESET"  1>&2
    }
# }}}

# Basic function {{{
    function yp() {
        realpath ${1-.} | xclip
    }

    function xcp() {
        if [ -z $1 ]; then
            realpath $(xclip -o) | xclip
        else
            realpath $1 | xclip
        fi
    }

    function xpa() {
        cp -v $(xclip -o) ${1-.}
    }
# }}}

# go proxy {{{
    # export PROXY_BIN=~/.local/bin/goproxy/proxy

    # function goproxy() {
    #     local proxy_mode=${1:-"first"}
    #     local protocal=${2:-"http"}
    #     local port=${3:-"3322"}
    #     local remote=${4:-remotehost:4780}
    #     if [ $proxy_mode = "first" ]; then
    #         $PROXY_BIN $protocal -t tcp -p "0.0.0.0:$port" \
    #             --daemon --log="/tmp/goproxy-$port.log"
    #     elif [ $proxy_mode = "second" ]; then
    #         $PROXY_BIN $protocal -t tcp -p "0.0.0.0:$port" \
    #             -T tcp -P "$remote"\
    #             --daemon --log="/tmp/goproxy-$port.log"
    #     else
    #         echo "go proxy mode wrong"
    #     fi
    # }

    # function gostart() {
    #     local proxy_mode=${1:-"first"}
    #     local proxy_port=${2:-$PROXY_PORT}
    #     if [ $proxy_mode = "first" ]; then
    #         # goproxy "first" "http"   $proxy_port       
    #         # goproxy "first" "socks"  $(($proxy_port+1))
    #         goproxy "first"  "http"   $(($proxy_port+2))
    #     elif [ $proxy_mode = "second" ]; then
    #         goproxy "second" "http"   $(($proxy_port+0))  "$TARGETHOST:4780"
    #         goproxy "second" "socks"  $(($proxy_port+1))  "$TARGETHOST:4781"
    #         goproxy "second" "http"   $(($proxy_port+2))  "$TARGETHOST:10809"
    #         goproxy "second" "socks"   $(($proxy_port+3))  "$TARGETHOST:10808"
    #         # goproxy "second" "http"   $(($proxy_port+2))  "$TARGETHOST:$(($proxy_port+2))"
    #     fi
    # }

    # function gostop() {
    #     killall proxy
    # }

    # function gostatus() {
    #     ps -ef | grep goproxy | grep -v grep
    # }
# }}}

# Key Map for terminal ----------------- {{{
    # Oh-My-Zsh {{{
        ## ref - https://www.zhihu.com/question/49284484
        bindkey '^P' history-substring-search-up
        bindkey '^N' history-substring-search-down
        bindkey ',' autosuggest-accept
        bindkey \^U backward-kill-line
    # }}}

    # FZF key binding {{{
        # what we expect is `   sort -t\| -gr -k2 /home/z/.z | awk -F\| "{print \$1}"   `
        # Because here the cmd will be subtituded twice, so we need to take care of escape.
        # Double quote can be nest while single quote cant. we must use escape to take care of quote matching
        # https://stackoverflow.com/questions/6697753/difference-between-single-and-double-quotes-in-bash/42082956#42082956
        # FZF
        export FZF_CTRL_T_OPTS="
            --prompt 'All> '
            --border
            --reverse
            --height 60%
            --preview '
            (
                ~/.config/fzf/fzf-scope.sh {} ||
                tree -ahpCL 3 -I '.git' -I '__pycache__' {}  ||
                echo preview {} fail
            ) 2>/dev/null | head -n 100
            '
            --header 'CTRL-D: Directories / CTRL-F: Files / CTRL-T: Zlua'
            --bind 'ctrl-d:change-prompt(Directories> )+reload(find * -type d)'
            --bind 'ctrl-f:change-prompt(Files> )+reload(find * -type f)'
            --bind 'ctrl-t:change-prompt(Zlua> )+reload(sort -t\| -gr -k2 ~/.zlua | awk -F\| \"{print \\\$1}\")'
            "
        # CTRL-/ to toggle small preview window to see the full command
        # CTRL-Y to copy the command into clipboard using pbcopy
        export FZF_CTRL_R_OPTS="
            --header 'Press CTRL-Y to copy command into clipboard'
            --reverse
            --preview 'echo {}' --preview-window up:3:hidden:wrap
            --bind 'ctrl-/:toggle-preview'
            --bind 'ctrl-y:execute-silent(echo -n {2..} | wl-copy)+abort'
            "

        function _fzf_complete_ping () {
            _fzf_complete +m -- "$@" < <(
                command grep -v '^\s*\(#\|$\)' /etc/hosts | command grep -Fv '0.0.0.0' |
                    awk '{if (length($2) > 0) {print $2}}' | sort -u
                )
        }
    # }}}
# }}}

# Tmux config in fzf way - now is rarely used {{{
    # https://github.com/junegunn/fzf/wiki/examples#tmux
    # it does not well done, because mask the auto-complete in the dafault shell
    # zsh; needs setopt re_match_pcre. You can, of course, adapt it to your own shell easily.
    function tmk () {
        local sessions
        sessions="$(tmux ls | fzf --exit-0 --multi)"  || return $?
        local i
        for i in "${(f@)sessions}"
        do
            [[ $i =~ '([^:]*):.*' ]] && {
                echo "Killing $match[1]"
                tmux kill-session -t "$match[1]"
            }
        done
    }

    # tm - create new tmux session, or switch to existing one. Works from within tmux too. (@bag-man)
    # `tm` will allow you to select your tmux session via fzf.
    # `tm irc` will attach to the irc session (if it exists), else it will create it.
    function tm() {
      local change="switch-client"
      [[ -n "$TMUX" ]] || change="attach-session"
      if [ $1 ]; then
        tmux $change -t "$1" 2>/dev/null || (tmux new-session -d -s $1 && tmux $change -t "$1"); return
      fi
      session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --exit-0) &&  tmux $change -t "$session" || echo "No sessions found."
    }
# }}}

# WSL config {{{
    # Fix xclip, so we can copy between win10 and linux.
    # Xclip depends on x11 on linux and Xserver on win10.
    # To make xclip works on vim, we also need install vim-gtk
    if uname -r | grep -qi "microsof" ; then
        fmt_info "We are in wsl~~~"

        # Export for WSL {{{
            # sys tools
            # export POWERSHELL_PATH="/mnt/c/Windows/System32/WindowsPowerShell/v1.0/powerShell.exe"
            export VSCODE_PATH="/mnt/c/Program Files/Microsoft VS Code/bin/code"
            export EXPLORER_PATH="/mnt/c/Windows/explorer.exe"
            export CMD_PATH="/mnt/c/Windows/system32/cmd.exe"
            export TYPORA_PATH="/mnt/c/Program Files/Typora/Typora.exe"
            export OBSIDIAN_PATH="/mnt/c/Users/owen/AppData/Local/Obsidian/Obsidian.exe"
            export DRAWIO_PATH="/mnt/c/Program Files/draw.io/draw.io.exe"

            # network
            # export REMOTEHOST=${REMOTEHOST:-127.0.0.1}
            # export CLOUDHOST=${CLOUDHOST:-127.0.0.1}
            # export OPEN_PORTS_NUM=${OPEN_PORTS_NUM:-10}
            # export OPEN_PORTS_BASE=${OPEN_PORTS_BASE:-3050}
            # export PROXY_MODE=${PROXY_MODE:-"first"}
            # export TARGETHOST=${TARGETHOST:-"cloudhost"}
            export PROXY_PORT=${PROXY_PORT:-10809}
            # export all_proxy="http://$WINIP:$PROXY_PORT"
            export WSL_GATEWAY=$(ip route | grep -w default | awk '{print $3}')
            export WINIP=${WSL_GATEWAY}
            export WSLIP=$(ip addr show dev eth0 | sed -n 's#.*inet \([^/]*\).*#\1#p')
            # export WINIP=${WINIP:-192.168.50.10}
            export all_proxy=${all_proxy:-http://$WSL_GATEWAY:10809}
            # export all_proxy="socks5://$WINIP:10808" # v2ray
            # export DISPLAY="$WINIP:0.0"              # For X11 server, so we can xclip.
            export DISPLAY=":0.0"   # For xwayland server. It is unix socket.
            export CONFIG_INSTALL_DIR_IN_WSL=
            export CONFIG_INSTALL_DIR_IN_WIN="/mnt/d"

            # Xserver connection check. It costs 1s.
            for i in $(seq 0 3); do
                # nc -zv winhost $((6000+$i)) -w1 2>& /dev/null
                timeout 0.2 nc -zv winhost $((6000+$i)) 2>& /dev/null
                [ $? != 0 ] && break
            done
            if [ $i -eq 0 ]; then
                fmt_warn "Xserver is unreachable"
                unalias vim 2>&/dev/null
                unset DISPLAY_XSERVER
            else
                fmt_info "Xserver is reachable at $DISPLAY_XSERVER"
                # xserver is running
                LAST_MONITOR=$((i-1))
                export DISPLAY_XSERVER=${WSL_GATEWAY}:${LAST_MONITOR}.0   # For mobaxterm x11 server.
                if [[ -n $WAYLAND_DISPLAY ]]; then
                    # Use xserver for clip in vim. Wayland is not for copy.
                    alias vim="DISPLAY=$DISPLAY_XSERVER vim "
                fi
            fi
        # }}}

        # Alias for WSL {{{
            alias \
            cmd="$CMD_PATH /C start "                             \
            wexp="$EXPLORER_PATH"                                 \
            wslp=wslpath                                          \
            winp="wslpath -w"                                     \
            hosts="vim /mnt/c/Windows/System32/drivers/etc/hosts" \
            pshc="vim $WinUserHome/Documents/WindowsPowerShell/Microsoft.PowerShell_profile.ps1" \
        # }}}

        # Network - init when WSL starting {{{
            local linux_wsl_started_flag=/tmp/.wsl_linux_started
            if [ ! -f $linux_wsl_started_flag ]; then 
                fmt_info "$WSL_DISTRO_NAME WSL is starting~~~"
                fmt_info "Configing"
                # etc/win10/init-wsl.ps1
                powershell.exe -File $PshDir'init-wsl.ps1' \
                    $WSL_DISTRO_NAME  $WSLIP  $WINIP  $PshDir
                # /tmp is tmpfs. Everytime linux system restart, /tmp will be flush
                touch $linux_wsl_started_flag    
            else
                fmt_info "$WSL_DISTRO_NAME WSL is already started~~~"
            fi

            local wsl_started_flag=/mnt/wsl/.wsl_started
            if [ ! -f $wsl_started_flag ]; then 
                fmt_info "Win10 WSL service is starting~~~"
                fmt_info "Configing none now"
                touch $wsl_started_flag    
            else
                fmt_info "Win10 WSL service is already started~~~"
            fi
        # }}}

        # Key map - AHK key map for Win10{{{
            # explorer.exe "D:\.local\win10\keyremap.ahk"                                           # etc/win10/keyremap.ahk
            powershell.exe -File $PshDir"EntryAtLogOn.ps1"
        # }}}

        # Function for WSL {{{
            # system control{{{
                function shutdown() {
                    printf "shutdown $WSL_DISTRO_NAME ? [y/N]: " 
                    if read -q; then 
                        echo;  
                        powershell.exe wsl --terminate $WSL_DISTRO_NAME
                    fi
                }
            
                function IsWslPath() {
                    local filepath="$1"
                    echo "$filepath" | grep -q '/'
                    return $?
                }

                function check_and_return_winpath_array() {
                    g_winpaths=() # global var for return
                    local wslpaths=("$@")
                    local var winpath wslpath
                    for var in $(echo $wslpaths); do
                        if IsWslPath "$var"; then
                            # WSL path => Windows path
                            winpath=$(wslpath -wa "$var")
                            wslpath="$var"
                            if [[ $? != 0 ]] { return -1 }
                        else
                            winpath="$var"
                            wslpath=$(wslpath -ua "$var")
                            if [[ $? != 0 ]] { return -1 }
                        fi
                        if [ ! -e $wslpath  ]; then
                            fmt_error "$var" is no exist.
                            return -1
                        fi
                        g_winpaths+=("$winpath")
                        # echo "$winpath"
                    done
                    return 0
                }
                # call win exe with args convertion (wslpath => winpath)
                function call_win_exe() {
                    # check number of args.
                    # first arg is for limit args for win exe
                    local limit_num_of_args="${1}"
                    # get args [2,end] for win exe
                    local num_of_args="$(($# - 1))"
                    local args_for_exe=${@:2:$#}
                    if [[ $limit_num_of_args != -1 ]] &&   # -1 means no limit
                        [[ $num_of_args > $limit_num_of_args ]] {
                        print "too many args for win exe" \
                            "($num_of_args>$limit_num_of_args(limit))."
                        return -1
                    }
                    # iterate args from wslpaths => winpaths
                    # return g_winpaths array for winpaths
                    check_and_return_winpath_array $args_for_exe[@]
                    if [[ $? != 0 ]] {
                        print "args is illegal"
                        return -1
                    }
                    # execute win exe
                    "$g_win_cmdlist[@]" "$g_winpaths[@]"
                    return 0
                }
                function exp() {
                    1=${1:-.}  # default current directory
                    g_win_cmdlist=("$EXPLORER_PATH")
                    call_win_exe 1 "${@}"
                    [[ $? != 0 ]] && return -1
                }
                function rgf() {
                    rg --color=always --line-number --no-heading --smart-case "${*:-}" |
                      fzf --ansi \
                          --color "hl:-1:underline,hl+:-1:underline:reverse" \
                          --delimiter : \
                          --preview 'bat --color=always {1} --highlight-line {2}' \
                          --preview-window 'up,60%,border-bottom,+{2}+3/3,~3' \
                          --bind 'enter:become(vim {1} +{2})'
                }
                function pshfile() {
                    check_and_return_winpath_array ${@}
                    if [[ $? != 0 ]] {
                        print "args is illegal"
                        return -1
                    }
                    powershell.exe -File "$g_winpaths[@]"
                }
                function ty() {
                    g_win_cmdlist=("$TYPORA_PATH")
                    call_win_exe 1 "${@}"
                    [[ $? != 0 ]] && return -1
                }
                function ob() {
                    g_win_cmdlist=("$OBSIDIAN_PATH")
                    call_win_exe 1 "${@}"
                    [[ $? != 0 ]] && return -1
                }
                function code() {
                    # vscode only receive wsl path
                    # g_win_cmdlist=("$VSCODE_PATH")
                    # call_win_exe -1 "${@}"
                    1=${1:-.}
                    $VSCODE_PATH "${@}"
                    [[ $? != 0 ]] && return -1
                }
                function da() {
                    g_win_cmdlist=("$DRAWIO_PATH")
                    call_win_exe 1 "${@}"
                    [[ $? != 0 ]] && return -1
                }
                function wpwd() {
                    local dir=${1:-"."}
                    wslpath -wa "$dir"
                }
                function wrp() {
                    local dir=${1:-"."}
                    wslpath -wa "$dir"
                }
            # }}}

            # droplist - manipulate win10 droplist (win10 clipboard) {{{
                function pshfile() {
                    local file=${PshDir}${1}
                    local action=${2}
                    local args_for_exe=${@:3:$#}
                    g_win_cmdlist=(powershell.exe -File $file $action)
                    call_win_exe -1 "$args_for_exe[@]"
                    [[ $? != 0 ]] && return -1
                }
                function yww() {
                    pshfile 'clipboard.ps1' "set" "${@}"
                    # g_win_cmdlist=(powershell.exe -File $PshDir'file2clip.ps1')
                    # call_win_exe -1 "${@}"
                    return $?
                }
                function ywa() {
                    pshfile 'clipboard.ps1' "push" "${@}"
                    return $?
                }
                # function pw() {
                #     DesDirPath=${1:-.}   # default DesDirPath is "."(current directory)
                #     # ${CONFIG_INSTALL_DIR_IN_WIN}/.local/win10/clip2file.sh $DesDirPath       # etc/win10/clip2file.ps1
                #     /mnt/d/.local/win10/clip2file.sh $DesDirPath       # etc/win10/clip2file.ps1
                #     # /mnt/d/.local/win10/clip2file.sh $DesDirPath       # etc/win10/clip2file.ps1
                # }

                function pww() {
                    local DesDirPath=$(wslpath -wa ${1:-.})
                    local imageName=${2:-"screenshot_"$(date +%Y%m%d-%H%M%S)".png"}
                    # powershell.exe -File $PshDir'clip2file.ps1' "$DesDirPath" "$imageName"  # etc/win10/clip2file.ps1
                    powershell.exe -File ${PshDir}'clipboard.ps1' "get" "$DesDirPath" "$imageName"
                }

                function pwm() {
                    DesDirPath=$(wslpath -wa ${1:-.})
                    # powershell.exe -File $PshDir'mv-clip2file.ps1' "$DesDirPath"       # etc/win10/mv-clip2file.ps1
                    pshfile 'mv-clip2file.ps1' "$DesDirPath"
                }
                alias pm=pwm
                function pwl() {
                    DesDirPath=$(wslpath -wa ${1:-.})
                    # powershell.exe -File $PshDir'set-shortcut-from-clipboard.ps1' "$DesDirPath"  # etc/win10/set-shortcut-from-clipboard.ps1
                    pshfile 'set-shortcut-from-clipboard.ps1' "$DesDirPath"
                }
                function musb {
                    sudo mkdir /mnt/$1
                    sudo mount -t drvfs $1: /mnt/$1
                }
                # function err_owen() {
                #     echo "$funcstack[2]: $@" 1>&2
                # }
                # function echo_owen() {
                #     echo "$funcstack[2]: $@"
                # }
                function wcd() {
                    [[ $# != 1 ]] && fmt_error "must have 1 arg" && return 1
                    local wslpath="$(wslpath "$*")"
                    fmt_info "cd to ${wslpath}"
                    cd "${wslpath}"
                }
            # }}}
        # }}}
    fi
# }}}

# FZF - https://github.com/junegunn/fzf#using-git {{{
    [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
# }}}

# Zplug manage plug {{{
    ## oh-my-zsh plugins # Supports oh-my-zsh plugins and the like
    ## config plugin
    if [[ -f ~/.zplug/init.zsh ]] {
      source ~/.zplug/init.zsh
      # export ZPLUG_THREADS=${ZPLUG_THREADS:-1}

      # oh-my-zsh inner option plugins
      zplug "plugins/git",   from:oh-my-zsh, depth:1
      # zplug "plugins/z",   from:oh-my-zsh, depth:1
      zplug "plugins/rand-quote",   from:oh-my-zsh, depth:1
      zplug "plugins/themes",   from:oh-my-zsh, depth:1
      zplug "plugins/gitignore",   from:oh-my-zsh, depth:1
      zplug "plugins/cp",   from:oh-my-zsh, depth:1
      zplug "plugins/extract",   from:oh-my-zsh, depth:1
      zplug "plugins/zsh_reload",   from:oh-my-zsh, depth:1
      zplug "plugins/safe-paste",   from:oh-my-zsh, depth:1
      zplug "plugins/colored-man-pages",   from:oh-my-zsh, depth:1
    # zplug "plugins/vi-mode",   from:oh-my-zsh    But I prefer this in emacs way
    # zplug "plugins/zsh-vim-mode",   from:oh-my-zsh, depth:1
      zplug "plugins/history-substring-search",   from:oh-my-zsh, depth:1
      zplug "plugins/sudo",   from:oh-my-zsh, depth:1

      # config plugs
      zplug "skywind3000/z.lua", depth:1
      zplug "supercrabtree/k", depth:1
      zplug "denisidoro/navi", depth:1
      zplug "MichaelAquilina/zsh-you-should-use", depth:1
      zplug "changyuheng/zsh-interactive-cd", depth:1
      zplug "SleepyBag/zsh-confer", depth:1
      zplug "zsh-users/zsh-syntax-highlighting", depth:1
      zplug "zsh-users/zsh-autosuggestions", depth:1
      zplug "paulirish/git-open", depth:1

    # zplug "Powerlevel9k/powerlevel9k", from:github, as:theme, if:"[[ $ZSH_THEME_STYLE == 9k ]]"
    # zplug "denysdovhan/spaceship-prompt", use:spaceship.zsh-theme, from:github, as:theme, if:"[[ $ZSH_THEME_STYLE == spaceship ]]"
    # zplug "caiogondim/bullet-train.zsh", use:bullet-train.zsh-theme, from:github, as:theme, if:"[[ $ZSH_THEME_STYLE == bullet ]]"
    # zplug "skylerlee/zeta-zsh-theme", from:github, as:theme, if:"[[ $ZSH_THEME_STYLE == zeta ]]"

      # Install plugins if there are plugins that have not been installed
      if ! zplug check --verbose; then
          printf "Install? [y/N]: "
          if read -q; then
              echo; zplug install
          fi
      fi
      # Then, source plugins and add commands to $PATH
      zplug load

      ## after plug loaded
      ## zsh-autosuggestions - note the source command must be at the end of .zshrc
      source "$ZPLUG_REPOS/zsh-users/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
    } else {
        fmt_error "Do not install zplug, please install!"
        # echo "# curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh"
        curl -sL --proto-redir -all,https https://raw.githubusercontent.com/zplug/installer/master/installer.zsh | zsh
    }

    # if [[ -e $HOME/.local/share/zinit/zinit.git/zinit.zsh ]]; then
    #     # 快速目录跳转
    #     zinit ice lucid wait='1'
    #     zinit light skywind3000/z.lua

    #     # 语法高亮
    #     # zinit ice lucid wait='0' atinit='zpcompinit'
    #     # zinit light zdharma/fast-syntax-highlighting

    #     zinit light zsh-users/zsh-syntax-highlighting

    #     # 自动建议
    #     zinit ice lucid wait="0" atload='_zsh_autosuggest_start'
    #     zinit light zsh-users/zsh-autosuggestions

    #     # 补全
    #     zinit ice lucid wait='0'
    #     zinit light zsh-users/zsh-completions

    #     zinit light changyuheng/zsh-interactive-cd
    #     zinit light paulirish/git-open
    #     zinit light MichaelAquilina/zsh-you-should-use

    #     # 加载 OMZ 框架及部分插件
    #     zinit snippet OMZ::lib/completion.zsh
    #     zinit snippet OMZ::lib/history.zsh
    #     zinit snippet OMZ::lib/key-bindings.zsh
    #     zinit snippet OMZ::lib/theme-and-appearance.zsh
    #     zinit snippet OMZ::lib/git.zsh

    #     zinit snippet OMZT::robbyrussell

    #     zinit snippet OMZ::plugins/colored-man-pages/colored-man-pages.plugin.zsh
    #     zinit snippet OMZ::plugins/sudo/sudo.plugin.zsh
    #     zinit snippet OMZ::plugins/safe-paste/safe-paste.plugin.zsh
    #     # zinit snippet OMZ::plugins/history-substring-search/history-substring-search.plugin.zsh
    #     zinit snippet OMZ::plugins/gitignore/gitignore.plugin.zsh
    #     zinit snippet OMZ::plugins/themes/themes.plugin.zsh
    #     zinit snippet OMZ::plugins/history-substring-search/history-substring-search.plugin.zsh

    #     zinit ice svn
    #     zinit snippet OMZ::plugins/extract

    #     zinit ice lucid wait='1'
    #     zinit snippet OMZ::plugins/git/git.plugin.zsh
    #     zinit snippet OMZ::plugins/cp/cp.plugin.zsh
    #     # source "~/.local/share/zinit/snippets/OMZ::plugins--history-substring-search/history-substring-search.plugin.zsh"
    # else
    #     # echo "Do not install zinit, please install!"
    # fi
# }}}

